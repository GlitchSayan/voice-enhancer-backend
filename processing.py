# -*- coding: utf-8 -*-
"""Voice_Enhancer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q_ZjiWAM6DOnwZrkooaXBddbb9Da_L2a
"""

!pip install librosa soundfile scipy numpy matplotlib

!apt-get install ffmpeg
!pip install pydub

from google.colab import files
from pydub import AudioSegment

uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load .m4a
audio_m4a = AudioSegment.from_file(filename, format="m4a")

# Convert to wav
wav_filename = "converted.wav"
audio_m4a.export(wav_filename, format="wav")

print("Converted:", wav_filename)

from pydub import AudioSegment
import numpy as np

sound = AudioSegment.from_file(filename)
sound = sound.set_channels(1)
sound = sound.set_frame_rate(44100)
sound = sound.set_sample_width(2)  # 16-bit PCM

samples = np.array(sound.get_array_of_samples()).astype(np.float32)
audio = samples / (2**15)      # normalize
sr = sound.frame_rate

print("Audio loaded:", audio.shape, sr)

import numpy as np
from scipy.signal import stft, istft

def spectral_noise_reduce(audio, sr):
    f, t, Zxx = stft(audio, fs=sr, nperseg=1024)

    noise_profile = np.mean(np.abs(Zxx[:, :10]), axis=1, keepdims=True)

    magnitude = np.abs(Zxx)
    phase = np.angle(Zxx)

    k = 0.8
    mask = magnitude > k * noise_profile
    enhanced_mag = magnitude * mask

    Zxx_enhanced = enhanced_mag * np.exp(1j * phase)
    _, enhanced_audio = istft(Zxx_enhanced, fs=sr)

    return enhanced_audio

from scipy.signal import iirpeak, lfilter

def apply_eq(audio, sr):
    def boost(freq, Q, gain_db):
        gain = 10 ** (gain_db / 20)
        w0 = freq / (sr / 2)
        b, a = iirpeak(w0, Q)
        return lfilter(b, a, audio) * gain

    out = audio.copy()
    out += boost(250, 2, 1.5)     # Warmth
    out += boost(3000, 2, 2.0)    # Clarity
    return out

import numpy as np

# Convert stereo to mono
if len(audio.shape) == 2:
    audio = np.mean(audio, axis=1)

print("Audio is now mono:", audio.shape)

import numpy as np

def smooth_compress(audio, threshold=0.1, ratio=3, attack=0.01, release=0.1):
    out = np.zeros_like(audio)
    gain = 1.0

    for i, sample in enumerate(audio):
        abs_sample = abs(sample)

        if abs_sample > threshold:
            target_gain = threshold + (abs_sample - threshold) / ratio
            target_gain /= abs_sample
        else:
            target_gain = 1.0

        # Smooth the gain change
        if target_gain < gain:
            gain = gain - attack * (gain - target_gain)
        else:
            gain = gain + release * (target_gain - gain)

        out[i] = sample * gain

    return out

import numpy as np
from scipy.signal import stft, istft

def soft_anc(audio, sr, noise_frames=20, alpha=1.5, beta=0.002):
    """
    audio: numpy array, mono
    sr: sample rate
    noise_frames: number of frames assumed to contain only noise
    alpha: over-subtraction factor (strength of ANC)
    beta: spectral floor to prevent musical noise
    """

    # STFT
    f, t, Zxx = stft(audio, fs=sr, nperseg=1024)
    mag = np.abs(Zxx)
    phase = np.angle(Zxx)

    # Noise estimate from first noise_frames
    noise_mag = np.mean(mag[:, :noise_frames], axis=1, keepdims=True)

    # Apply advanced spectral subtraction: |S| = |Y| - α|N|
    subtracted = mag - alpha * noise_mag

    # Prevent negative / zero values → spectral flooring
    subtracted = np.maximum(subtracted, beta * noise_mag)

    # Reconstruct complex STFT
    Zxx_clean = subtracted * np.exp(1j * phase)

    # Inverse STFT
    _, enhanced = istft(Zxx_clean, fs=sr)

    return enhanced

def process_audio(audio, sr):
    print("Applying Soft ANC...")
    anc = soft_anc(audio, sr)

    print("Compressing...")
    compressed = smooth_compress(anc)

    print("Applying EQ...")
    enhanced = apply_eq(compressed, sr)

    return enhanced

import soundfile as sf

def process_audio_file(in_path, out_path):
    audio, sr = sf.read(in_path)

    # Convert stereo → mono
    if len(audio.shape) == 2:
        audio = audio.mean(axis=1)

    enhanced = process_audio(audio, sr)

    sf.write(out_path, enhanced, sr)

output = process_audio(audio, sr)
sf.write("enhanced_output.wav", output, sr)

files.download("enhanced_output.wav")